name: Label - Ready to Merge

on:
  workflow_run:
    workflows: ['CI Backend', 'CI Frontend']
    types: [completed]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  add-label-if-all-jobs-passed:
    if: github.event.workflow_run.conclusion == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Validar jobs da pipeline e etiquetar PR
        uses: actions/github-script@v7
        env:
          HEAD_BRANCH: ${{ github.event.workflow_run.head_branch }}
          HEAD_SHA: ${{ github.event.workflow_run.head_sha }}
          WORKFLOW_RUN_ID: ${{ github.event.workflow_run.id }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const branch = process.env.HEAD_BRANCH;
            const sha = process.env.HEAD_SHA;
            const runId = process.env.WORKFLOW_RUN_ID;

            const allowedPrefixes = ['dependabot/', 'hotfix/', 'release/', 'bugfix/', 'feature/', 'chore/'];
            const isAllowed = allowedPrefixes.some(prefix => branch.startsWith(prefix));

            if (!isAllowed) {
              console.log(`Branch '${branch}' não tem prefixo permitido. Ignorando.`);
              return;
            }

            // Encontrar PR aberto para este branch
            const prs = await github.rest.pulls.list({ owner, repo, state: 'open', head: `${owner}:${branch}` });
            if (!prs.data.length) {
              core.info(`Nenhum PR aberto para o branch '${branch}'.`);
              return;
            }
            const pr = prs.data[0];

            // Obter checks obrigatórios da proteção da branch base (ex.: main)
            let requiredContexts = [];
            try {
              const bp = await github.rest.repos.getBranchProtection({ owner, repo, branch: pr.base.ref });
              const checks = bp.data.required_status_checks?.checks || [];
              requiredContexts = checks.map(c => c.context).filter(Boolean);
            } catch (e) {
              core.info(`Branch protection não acessível ou não configurada. Caindo no fallback dos nomes dos jobs.`);
            }

            // Fallback: se não houver branch protection configurada, exigir nossos jobs principais no pull_request
            if (requiredContexts.length === 0) {
              requiredContexts = [
                'CI Backend / build-test-backend (pull_request)',
                'CI Frontend / build-test-frontend (pull_request)'
              ];
            }

            // Verificar estado dos checks para este SHA via Checks API
            const checksResp = await github.rest.checks.listForRef({ owner, repo, ref: sha, per_page: 100 });
            const byName = new Map();
            for (const run of checksResp.data.check_runs) {
              const list = byName.get(run.name) || [];
              byName.set(run.name, [...list, run]);
            }
            const allRequiredGreen = requiredContexts.every(name => {
              const runs = byName.get(name) || [];
              if (!runs.length) return false;
              const latest = runs.sort((a,b) => new Date(b.completed_at || 0) - new Date(a.completed_at || 0))[0];
              return latest && latest.status === 'completed' && latest.conclusion === 'success';
            });

            if (!allRequiredGreen) {
              core.info('Nem todos os status checks obrigatórios estão verdes. Ignorando label por enquanto.');
              return;
            }

            // Adiciona label 'Ready to Merge'
            await github.rest.issues.addLabels({
              owner,
              repo,
              issue_number: pr.number,
              labels: ['Ready to Merge']
            });
            console.log(`Label 'Ready to Merge' adicionada ao PR #${pr.number}`);
