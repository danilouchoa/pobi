name: Label - Ready to Merge

on:
  workflow_run:
    workflows: ['CI Backend', 'CI Frontend']
    types: [completed]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  add-label-if-all-jobs-passed:
    if: github.event.workflow_run.conclusion == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Validar jobs da pipeline e etiquetar PR
        uses: actions/github-script@v7
        env:
          HEAD_BRANCH: ${{ github.event.workflow_run.head_branch }}
          HEAD_SHA: ${{ github.event.workflow_run.head_sha }}
          WORKFLOW_RUN_ID: ${{ github.event.workflow_run.id }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const branch = process.env.HEAD_BRANCH;
            const sha = process.env.HEAD_SHA;
            const runId = process.env.WORKFLOW_RUN_ID;

            const allowedPrefixes = ['dependabot/', 'hotfix/', 'release/', 'bugfix/', 'feature/', 'chore/'];
            const isAllowed = allowedPrefixes.some(prefix => branch.startsWith(prefix));

            if (!isAllowed) {
              console.log(`Branch '${branch}' não tem prefixo permitido. Ignorando.`);
              return;
            }

            // Conferir se os dois workflows (backend e frontend) deste commit concluíram com sucesso
            const requiredNames = ['CI Backend', 'CI Frontend'];
            const runsResp = await github.rest.actions.listWorkflowRunsForRepo({ owner, repo, head_sha: sha, per_page: 50 });
            const runsByName = new Map();
            for (const run of runsResp.data.workflow_runs) {
              if (requiredNames.includes(run.name)) {
                const prev = runsByName.get(run.name) || [];
                runsByName.set(run.name, [...prev, run]);
              }
            }
            const allSucceeded = requiredNames.every(name => {
              const list = (runsByName.get(name) || []).filter(r => r.head_branch === branch);
              if (!list.length) return false;
              // pegar o mais recente para este branch/sha
              const latest = list.sort((a,b) => new Date(b.updated_at) - new Date(a.updated_at))[0];
              return latest.conclusion === 'success';
            });

            if (!allSucceeded) {
              core.info('Nem todos os workflows CI passaram com sucesso para este commit. Ignorando label.');
              return;
            }

            // Busca PRs abertos para o branch
            const prs = await github.rest.pulls.list({ owner, repo, state: 'open', head: `${owner}:${branch}` });
            if (!prs.data.length) {
              console.log(`Nenhum PR aberto para o branch '${branch}'.`);
              return;
            }
            const pr = prs.data[0];

            // Adiciona label 'Ready to Merge'
            await github.rest.issues.addLabels({
              owner,
              repo,
              issue_number: pr.number,
              labels: ['Ready to Merge']
            });
            console.log(`Label 'Ready to Merge' adicionada ao PR #${pr.number}`);
