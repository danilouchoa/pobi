name: Label - Ready to Merge

on:
  workflow_run:
    workflows:
      - CI Backend
      - CI Frontend
      - CodeQL Security Analysis
    types: [completed]

permissions:
  contents: read
  pull-requests: write
  checks: read

jobs:
  label-ready:
    runs-on: ubuntu-latest
    steps:
      - name: Validar checks e aplicar label
        uses: actions/github-script@v7
        with:
          script: |
            // Configuração: nomes dos checks obrigatórios (job names)
            const REQUIRED_CHECKS = ['build-test-backend', 'build-test-frontend'];

            const { owner, repo } = context.repo;
            const sha = context.payload.workflow_run?.head_sha;
            const headBranch = context.payload.workflow_run?.head_branch;
            core.info(`workflow_run concluído para branch='${headBranch}', sha='${sha}'`);

            // Encontrar PR associado a este commit/branch
            let pr = null;
            try {
              const assoc = await github.rest.repos.listPullRequestsAssociatedWithCommit({ owner, repo, commit_sha: sha });
              const openPRs = assoc.data.filter(p => p.state === 'open');
              if (openPRs.length) pr = openPRs[0];
            } catch (e) {
              core.warning(`Falha ao buscar PRs pelo commit: ${e.message}`);
            }
            if (!pr) {
              try {
                const prs = await github.rest.pulls.list({ owner, repo, state: 'open', head: `${owner}:${headBranch}`, per_page: 10 });
                if (prs.data.length) pr = prs.data[0];
              } catch (e) {
                core.warning(`Falha ao buscar PRs pelo branch: ${e.message}`);
              }
            }
            if (!pr) {
              core.info('Nenhum PR aberto encontrado para este workflow_run. Encerrando.');
              return;
            }
            core.info(`PR encontrado: #${pr.number} -> base='${pr.base.ref}'`);

            // Listar check runs do commit
            const checksResp = await github.rest.checks.listForRef({ owner, repo, ref: sha, per_page: 100 });
            const runs = checksResp.data.check_runs || [];
            core.info(`Total de check runs encontrados: ${runs.length}`);

            // Normaliza nome no formato "Workflow / job" => pega somente a parte do job
            const normalize = (name) => {
              if (!name) return '';
              const parts = String(name).split(' / ');
              return parts[parts.length - 1];
            };

            const byName = new Map();
            for (const run of runs) {
              const key = normalize(run.name);
              const list = byName.get(key) || [];
              list.push(run);
              byName.set(key, list);
            }

            let allOk = true;
            for (const req of REQUIRED_CHECKS) {
              const candidates = byName.get(req) || [];
              if (!candidates.length) {
                core.warning(`Check obrigatório não encontrado: '${req}'`);
                allOk = false;
                continue;
              }
              const completed = candidates
                .filter(r => r.status === 'completed')
                .sort((a,b) => new Date(b.completed_at || 0) - new Date(a.completed_at || 0))[0];
              if (!completed) {
                core.warning(`Check '${req}' ainda não completou.`);
                allOk = false;
                continue;
              }
              core.info(`Check '${req}': status='${completed.status}', conclusão='${completed.conclusion}'`);
              if (completed.conclusion !== 'success') {
                allOk = false;
              }
            }

            if (!allOk) {
              core.info('Checks obrigatórios ainda não estão todos "success". Label será aplicada quando todos ficarem verdes.');
              return;
            }

            // Evitar duplicar label
            const existing = await github.rest.issues.listLabelsOnIssue({ owner, repo, issue_number: pr.number, per_page: 100 });
            const hasReady = existing.data.some(l => l.name === 'Ready to Merge');
            if (hasReady) {
              core.info("Label 'Ready to Merge' já existe no PR. Nada a fazer.");
              return;
            }

            await github.rest.issues.addLabels({ owner, repo, issue_number: pr.number, labels: ['Ready to Merge'] });
            core.info("Label 'Ready to Merge' aplicada com sucesso.");
